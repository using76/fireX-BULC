!> rief GPU Bridge Module for Triton Kernel Integration
!> Provides ISO_C_BINDING interface for Fortran-C-Python communication
!> NOTE: Uses local GPU_EB parameter to avoid PRECISION_PARAMETERS crash

MODULE GPU_BRIDGE

USE ISO_C_BINDING

IMPLICIT NONE (TYPE,EXTERNAL)

PRIVATE

! Local GPU precision parameter - always FP32 for GPU
! This avoids importing from PRECISION_PARAMETERS which causes crashes
INTEGER, PARAMETER :: EB_LOCAL = SELECTED_REAL_KIND(6)
INTEGER, PARAMETER, PUBLIC :: GPU_EB = EB_LOCAL

! Public interfaces
PUBLIC :: GPU_INIT, GPU_FINALIZE, GPU_IS_AVAILABLE
PUBLIC :: GPU_RADIATION_COMPUTE, GPU_SYNC
PUBLIC :: RADIATION_GPU_DATA
PUBLIC :: GPU_FILTER_COMPUTE, FILTER_GPU_DATA
PUBLIC :: GPU_VELOCITY_COMPUTE, VELOCITY_GPU_DATA
PUBLIC :: GPU_DIVERGENCE_COMPUTE, DIVERGENCE_GPU_DATA

! GPU availability flag
LOGICAL, SAVE :: GPU_INITIALIZED = .FALSE.
LOGICAL, SAVE :: GPU_AVAILABLE = .FALSE.

!> Radiation data structure for GPU transfer
TYPE, BIND(C) :: RADIATION_GPU_DATA
   TYPE(C_PTR) :: TMP_PTR          !< Temperature field pointer
   TYPE(C_PTR) :: KAPPA_GAS_PTR    !< Gas absorption coefficient pointer
   TYPE(C_PTR) :: IL_PTR           !< Radiation intensity pointer (input/output)
   TYPE(C_PTR) :: QR_PTR           !< Radiation source term pointer (output)
   TYPE(C_PTR) :: EXTCOE_PTR       !< Extinction coefficient pointer
   TYPE(C_PTR) :: SCAEFF_PTR       !< Scattering efficiency pointer
   INTEGER(C_INT) :: IBAR          !< Grid cells in X direction
   INTEGER(C_INT) :: JBAR          !< Grid cells in Y direction
   INTEGER(C_INT) :: KBAR          !< Grid cells in Z direction
   INTEGER(C_INT) :: NRA           !< Number of radiation angles
   INTEGER(C_INT) :: NBAND         !< Number of spectral bands
   REAL(C_FLOAT) :: DX             !< Grid spacing X
   REAL(C_FLOAT) :: DY             !< Grid spacing Y
   REAL(C_FLOAT) :: DZ             !< Grid spacing Z
   REAL(C_FLOAT) :: SIGMA          !< Stefan-Boltzmann constant
END TYPE RADIATION_GPU_DATA

!> Filter data structure
TYPE, BIND(C) :: FILTER_GPU_DATA
   TYPE(C_PTR) :: ORIG_PTR
   TYPE(C_PTR) :: HAT_PTR
   TYPE(C_PTR) :: K3D_PTR
   INTEGER(C_INT) :: IBAR, JBAR, KBAR
END TYPE FILTER_GPU_DATA

!> Velocity data structure
TYPE, BIND(C) :: VELOCITY_GPU_DATA
   TYPE(C_PTR) :: U_PTR, V_PTR, W_PTR
   TYPE(C_PTR) :: TMP_PTR, MU_PTR, STRAIN_PTR
   INTEGER(C_INT) :: IBAR, JBAR, KBAR
   REAL(C_FLOAT) :: RDX, RDY, RDZ
END TYPE VELOCITY_GPU_DATA

!> Divergence data structure
TYPE, BIND(C) :: DIVERGENCE_GPU_DATA
   TYPE(C_PTR) :: U_PTR, V_PTR, W_PTR
   TYPE(C_PTR) :: DIV_PTR, RHO_PTR
   INTEGER(C_INT) :: IBAR, JBAR, KBAR
   REAL(C_FLOAT) :: RDX, RDY, RDZ
END TYPE DIVERGENCE_GPU_DATA

! C function interfaces
INTERFACE
   FUNCTION gpu_bridge_init() BIND(C, NAME='gpu_bridge_init')
      IMPORT :: C_INT
      INTEGER(C_INT) :: gpu_bridge_init
   END FUNCTION gpu_bridge_init

   SUBROUTINE gpu_bridge_finalize() BIND(C, NAME='gpu_bridge_finalize')
   END SUBROUTINE gpu_bridge_finalize

   FUNCTION gpu_bridge_check_gpu() BIND(C, NAME='gpu_bridge_check_gpu')
      IMPORT :: C_INT
      INTEGER(C_INT) :: gpu_bridge_check_gpu
   END FUNCTION gpu_bridge_check_gpu

   FUNCTION gpu_radiation_kernel(data) BIND(C, NAME='gpu_radiation_kernel')
      IMPORT :: C_INT, RADIATION_GPU_DATA
      TYPE(RADIATION_GPU_DATA), INTENT(IN) :: data
      INTEGER(C_INT) :: gpu_radiation_kernel
   END FUNCTION gpu_radiation_kernel

   SUBROUTINE gpu_bridge_sync() BIND(C, NAME='gpu_bridge_sync')
   END SUBROUTINE gpu_bridge_sync

   FUNCTION gpu_filter_kernel(data) BIND(C, NAME='gpu_filter_kernel')
      IMPORT :: C_INT, FILTER_GPU_DATA
      TYPE(FILTER_GPU_DATA), INTENT(IN) :: data
      INTEGER(C_INT) :: gpu_filter_kernel
   END FUNCTION gpu_filter_kernel

   FUNCTION gpu_velocity_kernel(data) BIND(C, NAME='gpu_velocity_kernel')
      IMPORT :: C_INT, VELOCITY_GPU_DATA
      TYPE(VELOCITY_GPU_DATA), INTENT(IN) :: data
      INTEGER(C_INT) :: gpu_velocity_kernel
   END FUNCTION gpu_velocity_kernel

   FUNCTION gpu_divergence_kernel(data) BIND(C, NAME='gpu_divergence_kernel')
      IMPORT :: C_INT, DIVERGENCE_GPU_DATA
      TYPE(DIVERGENCE_GPU_DATA), INTENT(IN) :: data
      INTEGER(C_INT) :: gpu_divergence_kernel
   END FUNCTION gpu_divergence_kernel
END INTERFACE

CONTAINS

SUBROUTINE GPU_INIT(STATUS)
   INTEGER, INTENT(OUT) :: STATUS
   INTEGER(C_INT) :: C_STATUS

   IF (GPU_INITIALIZED) THEN
      STATUS = 0
      RETURN
   ENDIF

   C_STATUS = gpu_bridge_init()
   IF (C_STATUS /= 0) THEN
      STATUS = -1
      GPU_INITIALIZED = .FALSE.
      GPU_AVAILABLE = .FALSE.
      RETURN
   ENDIF

   C_STATUS = gpu_bridge_check_gpu()
   GPU_AVAILABLE = (C_STATUS == 1)
   GPU_INITIALIZED = .TRUE.
   STATUS = 0

END SUBROUTINE GPU_INIT

SUBROUTINE GPU_FINALIZE()
   IF (GPU_INITIALIZED) THEN
      CALL gpu_bridge_finalize()
      GPU_INITIALIZED = .FALSE.
      GPU_AVAILABLE = .FALSE.
   ENDIF
END SUBROUTINE GPU_FINALIZE

FUNCTION GPU_IS_AVAILABLE() RESULT(AVAILABLE)
   LOGICAL :: AVAILABLE
   AVAILABLE = GPU_INITIALIZED .AND. GPU_AVAILABLE
END FUNCTION GPU_IS_AVAILABLE

SUBROUTINE GPU_RADIATION_COMPUTE(TMP, KAPPA_GAS, IL, QR, EXTCOE, SCAEFF, &
                                  IBAR, JBAR, KBAR, NRA, NBAND, &
                                  DX, DY, DZ, SIGMA, STATUS)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: TMP(0:,0:,0:)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: KAPPA_GAS(:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(INOUT) :: IL(:,:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(OUT) :: QR(:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: EXTCOE(:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: SCAEFF(:,:,:)

   INTEGER, INTENT(IN) :: IBAR, JBAR, KBAR, NRA, NBAND
   REAL(EB_LOCAL), INTENT(IN) :: DX, DY, DZ, SIGMA
   INTEGER, INTENT(OUT) :: STATUS

   TYPE(RADIATION_GPU_DATA) :: GPU_DATA
   INTEGER(C_INT) :: C_STATUS

   IF (.NOT. GPU_IS_AVAILABLE()) THEN
      STATUS = -1
      RETURN
   ENDIF

   GPU_DATA%TMP_PTR = C_LOC(TMP(0,0,0))
   GPU_DATA%KAPPA_GAS_PTR = C_LOC(KAPPA_GAS(1,1,1))
   GPU_DATA%IL_PTR = C_LOC(IL(1,1,1,1))
   GPU_DATA%QR_PTR = C_LOC(QR(1,1,1))
   GPU_DATA%EXTCOE_PTR = C_LOC(EXTCOE(1,1,1))
   GPU_DATA%SCAEFF_PTR = C_LOC(SCAEFF(1,1,1))

   GPU_DATA%IBAR = INT(IBAR, C_INT)
   GPU_DATA%JBAR = INT(JBAR, C_INT)
   GPU_DATA%KBAR = INT(KBAR, C_INT)
   GPU_DATA%NRA = INT(NRA, C_INT)
   GPU_DATA%NBAND = INT(NBAND, C_INT)

   GPU_DATA%DX = REAL(DX, C_FLOAT)
   GPU_DATA%DY = REAL(DY, C_FLOAT)
   GPU_DATA%DZ = REAL(DZ, C_FLOAT)
   GPU_DATA%SIGMA = REAL(SIGMA, C_FLOAT)

   C_STATUS = gpu_radiation_kernel(GPU_DATA)

   IF (C_STATUS /= 0) THEN
      STATUS = -2
      RETURN
   ENDIF

   STATUS = 0

END SUBROUTINE GPU_RADIATION_COMPUTE

SUBROUTINE GPU_SYNC()
   IF (GPU_INITIALIZED) THEN
      CALL gpu_bridge_sync()
   ENDIF
END SUBROUTINE GPU_SYNC


SUBROUTINE GPU_FILTER_COMPUTE(ORIG, HAT, IBAR, JBAR, KBAR, STATUS)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: ORIG(:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(OUT) :: HAT(:,:,:)
   INTEGER, INTENT(IN) :: IBAR, JBAR, KBAR
   INTEGER, INTENT(OUT) :: STATUS
   TYPE(FILTER_GPU_DATA) :: GPU_DATA
   INTEGER(C_INT) :: C_STATUS
   IF (.NOT. GPU_IS_AVAILABLE()) THEN
      STATUS = -1
      RETURN
   ENDIF
   GPU_DATA%ORIG_PTR = C_LOC(ORIG(1,1,1))
   GPU_DATA%HAT_PTR = C_LOC(HAT(1,1,1))
   GPU_DATA%K3D_PTR = C_NULL_PTR
   GPU_DATA%IBAR = INT(IBAR, C_INT)
   GPU_DATA%JBAR = INT(JBAR, C_INT)
   GPU_DATA%KBAR = INT(KBAR, C_INT)
   C_STATUS = gpu_filter_kernel(GPU_DATA)
   STATUS = MERGE(-2, 0, C_STATUS /= 0)
END SUBROUTINE GPU_FILTER_COMPUTE

SUBROUTINE GPU_VELOCITY_COMPUTE(U, V, W, TMP, MU, STRAIN, IBAR, JBAR, KBAR, DX, DY, DZ, STATUS)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: U(:,:,:), V(:,:,:), W(:,:,:), TMP(:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(OUT) :: MU(:,:,:), STRAIN(:,:,:)
   INTEGER, INTENT(IN) :: IBAR, JBAR, KBAR
   REAL(EB_LOCAL), INTENT(IN) :: DX, DY, DZ
   INTEGER, INTENT(OUT) :: STATUS
   TYPE(VELOCITY_GPU_DATA) :: GPU_DATA
   INTEGER(C_INT) :: C_STATUS
   IF (.NOT. GPU_IS_AVAILABLE()) THEN
      STATUS = -1
      RETURN
   ENDIF
   GPU_DATA%U_PTR = C_LOC(U(1,1,1))
   GPU_DATA%V_PTR = C_LOC(V(1,1,1))
   GPU_DATA%W_PTR = C_LOC(W(1,1,1))
   GPU_DATA%TMP_PTR = C_LOC(TMP(1,1,1))
   GPU_DATA%MU_PTR = C_LOC(MU(1,1,1))
   GPU_DATA%STRAIN_PTR = C_LOC(STRAIN(1,1,1))
   GPU_DATA%IBAR = INT(IBAR, C_INT)
   GPU_DATA%JBAR = INT(JBAR, C_INT)
   GPU_DATA%KBAR = INT(KBAR, C_INT)
   GPU_DATA%RDX = REAL(1.0_EB_LOCAL/DX, C_FLOAT)
   GPU_DATA%RDY = REAL(1.0_EB_LOCAL/DY, C_FLOAT)
   GPU_DATA%RDZ = REAL(1.0_EB_LOCAL/DZ, C_FLOAT)
   C_STATUS = gpu_velocity_kernel(GPU_DATA)
   STATUS = MERGE(-2, 0, C_STATUS /= 0)
END SUBROUTINE GPU_VELOCITY_COMPUTE

SUBROUTINE GPU_DIVERGENCE_COMPUTE(U, V, W, DIV, RHO, IBAR, JBAR, KBAR, DX, DY, DZ, STATUS)
   REAL(EB_LOCAL), TARGET, INTENT(IN) :: U(:,:,:), V(:,:,:), W(:,:,:), RHO(:,:,:)
   REAL(EB_LOCAL), TARGET, INTENT(OUT) :: DIV(:,:,:)
   INTEGER, INTENT(IN) :: IBAR, JBAR, KBAR
   REAL(EB_LOCAL), INTENT(IN) :: DX, DY, DZ
   INTEGER, INTENT(OUT) :: STATUS
   TYPE(DIVERGENCE_GPU_DATA) :: GPU_DATA
   INTEGER(C_INT) :: C_STATUS
   IF (.NOT. GPU_IS_AVAILABLE()) THEN
      STATUS = -1
      RETURN
   ENDIF
   GPU_DATA%U_PTR = C_LOC(U(1,1,1))
   GPU_DATA%V_PTR = C_LOC(V(1,1,1))
   GPU_DATA%W_PTR = C_LOC(W(1,1,1))
   GPU_DATA%DIV_PTR = C_LOC(DIV(1,1,1))
   GPU_DATA%RHO_PTR = C_LOC(RHO(1,1,1))
   GPU_DATA%IBAR = INT(IBAR, C_INT)
   GPU_DATA%JBAR = INT(JBAR, C_INT)
   GPU_DATA%KBAR = INT(KBAR, C_INT)
   GPU_DATA%RDX = REAL(1.0_EB_LOCAL/DX, C_FLOAT)
   GPU_DATA%RDY = REAL(1.0_EB_LOCAL/DY, C_FLOAT)
   GPU_DATA%RDZ = REAL(1.0_EB_LOCAL/DZ, C_FLOAT)
   C_STATUS = gpu_divergence_kernel(GPU_DATA)
   STATUS = MERGE(-2, 0, C_STATUS /= 0)
END SUBROUTINE GPU_DIVERGENCE_COMPUTE

END MODULE GPU_BRIDGE
